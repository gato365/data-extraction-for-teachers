---
title: "Weather_Data_API"
author: ""
date: "`r Sys.Date()`"
output: html_document
---



```{r}
library(httr2)
library(tibble)
library(jsonlite)
library(httr)
library(lubridate)
library(ggplot2)
library(dplyr)
library(dotenv)
library(sf)
```

##

Session 2: OpenWeatherAPI Use
```{r}
getwd()

dotenv::load_dot_env(file = ".Renviron.txt")
api_key <- Sys.getenv("API_KEY")
```


# Step 0: Select a City

```{r}
city_name <- "San Luis Obispo"
```



# Working Query for Current Weather



```{r}
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"

current_query <- list(q = city_name, appid = api_key, units = "imperial")

response <- GET(current_weather_url, query = current_query)

http_type(response)

if (status_code(response) == 200) {
  # Parse and flatten JSON
  content_json <- content(response, as = "text", encoding = "UTF-8")
  parsed <- fromJSON(content_json, flatten = TRUE)
  
  # Convert to data frame directly
  currweather <- as.data.frame(parsed)
  
  print(names(currweather))
} else {
  cat("Failed. Status code:", status_code(response), "\n")
}

json_result <- content(response, as = "parsed")
class(json_result)
print(currweather)
```






## Obtain Past 5 Days Weather Given City

# Step 1: Use Geocoding API to get lattitude and longitude

# Step 1a: Construct URL query using city name and API key
```{r}
geo_url <- paste0(
  "http://api.openweathermap.org/geo/1.0/direct?",
  "q=", URLencode(city_name),
  "&limit=1&appid=", api_key
)
```

# Step 1b: Use GET to call the API and assign it to a variable geo_response. Use logic (if) to proceed if the status code is 200, and use fromJSON package jsonlite to get content from our API an use 'flatten = TRUE' to unnest the data.

The resulting data is in the JSON form, which appears as a named list sometimes containing other lists within in it, these being "nested."

* Define API, onecall, explain different endpoints
Benefits one vs others
Why to use a certain 


* Define numdays, include in function version
```{r}
numdays <- 5
```

```{r}
geo_response <- GET(geo_url)

if (status_code(geo_response) == 200) {
  geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
  
  
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.  
  if (length(geo_data) == 0) {
    stop("City not found. Please check the city name.")
  }
  
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
  
  lat <- round(geo_data$lat, digits = 2)
  lon <- round(geo_data$lon, digits = 2)
  
# Optional: Print a string displaying the city name and latitude / longitude.  
  cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
  
  
# Step 2: Use the One Call API to get the past 5 days of weather data  
  
# Step 2a: Define the date range (modify this as needed)

  date_range <- as.character(lubridate::today() - days(1:numdays)) # past 5 days turn into argumen to pass into function
  
# Step 2b: Initialize data frame to hold the outputs. "p5weather" for past 5 weather.
  p5weather <- data.frame()
  
# Step 2c: Loop over dates and make an API call for each day. For every date in the date vector, supply latitude, longitude, the different date, API key, and provide unit preference.
  for (date in date_range) {
    
    weather_url <- paste0(
      "https://api.openweathermap.org/data/3.0/onecall/day_summary?",
      "lat=", lat,
      "&lon=", lon,
      "&date=", date,
      "&appid=", api_key,
      "&units=imperial"
    )
    
# Step 2d: Make the API call using the different weather_url queries for each date. Store these in weather_response    
    
    weather_response <- GET(weather_url)
    
# Step 2e: Use logic to evaluate the response and use fromJSON() to get the content from the JSON output and use "flatten = TRUE" to unnest the data.
    
    if (status_code(weather_response) == 200) {
      weather_parsed <- jsonlite::fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
      
# Step 2f: Use the output for each day and assign it into a data frame.
      daily_df <- as.data.frame(weather_parsed)
      
# Step 2g: Add date and city name columns ## USE MUTATE
      daily_df$city <- city_name
      daily_df$date <- date
      
# Step 2h: Use bind_rows to add all the rows to the p5weather data frame.
      p5weather <- bind_rows(p5weather, daily_df)
      
    } else {
# Step 2i: Use logic (else) to print an error message for when weather data is not obtained.
      warning(paste("Failed to get weather for", date, "-", status_code(weather_response)))
    }
  }
  
  print(p5weather)
  
} else {
  stop("Geocoding failed. Check your API key or city name.")
}

```

development thing is another branch


turn into function

add detail


# Create a Visualization for the High and Low temperatures

```{r}

df4 <- p5weather |>  mutate(date = as.Date(date))

ggplot(df4, aes(x = date)) +
  geom_line(aes(y = temperature.max, color = "High"), size = 1.2) +
  geom_line(aes(y = temperature.min, color = "Low"), size = 1.2) +
  scale_color_manual(values = c("High" = "red", "Low" = "blue")) +
  labs(
    title = paste("High and Low Temperatures in", unique(df4$city)),
    x = "Date",
    y = "Temperature (°F)",
    color = "Temperature Type"
  ) +
  theme_minimal(base_size = 14)
```

```{r}

cities <- c("San Luis Obispo", "Santa Barbara", "San Francisco")

# Function to get coordinates + weather summary
get_city_weather <- function(city, date = Sys.Date()) {
  geo_url <- paste0(
    "http://api.openweathermap.org/geo/1.0/direct?",
    "q=", URLencode(city),
    "&limit=1&appid=", api_key
  )
  
  geo_response <- GET(geo_url)
  
  if (status_code(geo_response) == 200) {
    geo_data <- fromJSON(content(geo_response, as = "text"), flatten = TRUE)
    
    if (length(geo_data) == 0) return(NULL)
    
    lat <- geo_data$lat
    lon <- geo_data$lon
    
    weather_url <- paste0(
      "https://api.openweathermap.org/data/3.0/onecall/day_summary?",
      "lat=", lat,
      "&lon=", lon,
      "&date=", format(date, "%Y-%m-%d"),
      "&appid=", api_key,
      "&units=imperial"
    )
    
    weather_response <- GET(weather_url)
    
    if (status_code(weather_response) == 200) {
      weather_data <- fromJSON(content(weather_response, as = "text"), flatten = TRUE)
      
      tibble(
        city = city,
        date = date,
        lat = lat,
        lon = lon,
        temp_max = weather_data$temperature$max,
        temp_min = weather_data$temperature$min
      )
    } else return(NULL)
  } else return(NULL)
}

# Fetch for all cities
weather_df <- bind_rows(lapply(cities, get_city_weather))

```

```{r}
weather_sf <- weather_df %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)
```


```{r}
ggplot() +
  geom_sf(data = weather_sf, aes(color = temp_max), size = 6) +
  geom_sf_label(data = weather_sf, aes(label = city), nudge_y = 0.5, size = 4) +
  scale_color_viridis_c(option = "plasma", name = "High Temp (°F)") +
  labs(
    title = "California City Temperatures",
    subtitle = paste("Date:", Sys.Date())
  ) +
  theme_minimal()

```
```{r}
library(rnaturalearth)
library(rnaturalearthdata)

ca <- ne_states(country = "United States of America", returnclass = "sf") %>%
  filter(name == "California")

ggplot() +
  geom_sf(data = ca, fill = "gray95", color = "gray60") +
  geom_sf(data = weather_sf, aes(color = temp_max), size = 6) +
  geom_sf_label(data = weather_sf, aes(label = city), nudge_y = 0.5, size = 4) +
  scale_color_viridis_c(option = "plasma", name = "High Temp (°F)") +
  labs(
    title = "California City Temperatures",
    subtitle = paste("Date:", Sys.Date())
  ) +
  theme_minimal()

```



Table Representing


| JSON Key              | R Type    | Notes                      |
| --------------------- | --------- | -------------------------- |
| `temperature.min`     | numeric   | Minimum temp for the day   |
| `temperature.max`     | numeric   | Maximum temp for the day   |
| `humidity.morning`    | integer   | Morning humidity %         |
| `wind.max`            | numeric   | Peak wind speed            |
| `precipitation.total` | numeric   | Rain/snow total (mm or in) |
| `date` (added)   | Date      | From loop date             |
| `city` (added)   | character | City name from geocoding   |





The API returns a JSON object representing summary statistics for a specific location and date. The root of the JSON is a named list (in R, this becomes a named list or a single-row data.frame after fromJSON()).



temperature → Nested List → Becomes nested data.frame or named columns

    min: numeric (e.g., 50.1) → Low temp

    max: numeric (e.g., 75.6) → High temp

    afternoon, morning, evening, night: numeric

In R: These become temperature.min, temperature.max, etc. if you use flatten = TRUE with jsonlite::fromJSON().

humidity → Similar structure as temperature

    Each time-of-day (morning, evening...) → integer (%) → becomes humidity.morning, humidity.evening, etc.
    
  wind → List of stats

    max: numeric → max wind speed

    direction: numeric (degrees from North)

In R: wind.max, wind.direction

clouds, dew_point, precipitation, etc.

    Usually numeric → scalar values

    For example:

        precipitation.total → total mm of rain

        dew_point.afternoon → numeric

These all flatten into column names like precipitation.total, dew_point.afternoon.


| temperature.min | temperature.max | humidity.morning | wind.max | wind.direction | precipitation.total | date       | city            |
| --------------- | --------------- | ---------------- | -------- | -------------- | ------------------- | ---------- | --------------- |
| 50.1            | 75.6            | 80               | 12.3     | 270            | 0.5                 | 2025-04-23 | San Luis Obispo |



# Geocoding API


```{r}
geocode <- function(city){
  geo_url <- paste0(
  "http://api.openweathermap.org/geo/1.0/direct?",
  "q=", URLencode(city),
  "&limit=1&appid=", api_key
)


geo_response <- GET(geo_url)

if (status_code(geo_response) == 200) {
  geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
  
  
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.  
  if (length(geo_data) == 0) {
    stop("City not found. Please check the city name.")
  }
  
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
  
  lat <- round(geo_data$lat, digits = 2)
  lon <- round(geo_data$lon, digits = 2)
  
# Optional: Print a string displaying the city name and latitude / longitude.  
  return(cat("Coordinates for", city, "-> Latitude:", lat, "Longitude:", lon, "\n"))
   }
}
```



```{r}
geocode("San Francisco")
```


Function Version (Pick Any City by Name)



```{r}

curr_weather <- function(city){
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"

current_query <- list(q = city, appid = api_key, units = "imperial")

response <- GET(current_weather_url, query = current_query)

http_type(response)

json_result <- content(response, as = "parsed")
class(json_result)

name <- c()
weather <- c()
visibility <- c()
temp <- c()
temp_min <- c()
temp_max <- c()
pressure <- c()
humidity <- c()
wind_speed <- c()
wind_deg <- c()

name <- c(name, json_result$name)
weather <- c(weather, json_result$weather[[1]]$main)
# Get Visibility
visibility <- c(visibility, json_result$visibility)
# Get current temperature
temp <- c(temp, json_result$main$temp)
# Get min temperature
temp_min <- c(temp_min, json_result$main$temp_min)
# Get max temperature
temp_max <- c(temp_max, json_result$main$temp_max)
# Get pressure
pressure <- c(pressure, json_result$main$pressure)
# Get humidity
humidity <- c(humidity, json_result$main$humidity)
# Get wind speed
wind_speed <- c(wind_speed, json_result$wind$speed)
# Get wind direction
wind_deg <- c(wind_deg, json_result$wind$deg)

weather_data_frame <- data.frame(
  name = name,
  weather = weather,
  visibility = visibility,
  temp = temp,
  temp_min = temp_min,
  temp_max = temp_max,
  pressure = pressure,
  humidity = humidity,
  wind_speed = wind_speed,
  wind_deg = wind_deg
)

return(weather_data_frame)}
```





