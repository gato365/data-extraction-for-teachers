daily_df$city <- city_name
daily_df$date <- date
# Append to df3
df4 <- rbind(df4, daily_df)
} else {
warning(paste("Failed to get weather for", date, "-", status_code(weather_response)))
}
}
print(df4)
} else {
stop("Geocoding failed. Check your API key or city name.")
}
View(df4)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
# Step 2: Define the date range (modify this as needed)
date_range <- as.character(lubridate::today() - days(1:5)) # past 5 days
# Initialize df3 to hold all results
df4 <- data.frame()
# Step 3: Loop over dates and make an API call for each
for (date in date_range) {
weather_url <- paste0(
"https://api.openweathermap.org/data/3.0/onecall/day_summary?",
"lat=", lat,
"&lon=", lon,
"&date=", date,
"&appid=", api_key,
"&units=imperial"
)
weather_response <- GET(weather_url)
if (status_code(weather_response) == 200) {
weather_parsed <- fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Convert to a one-row data frame
daily_df <- as.data.frame(weather_parsed)
# Add the city and date columns
daily_df$city <- city_name
daily_df$date <- date
# Append to df3
df4 <- rbind(df4, daily_df)
} else {
warning(paste("Failed to get weather for", date, "-", status_code(weather_response)))
}
}
print(df4)
} else {
stop("Geocoding failed. Check your API key or city name.")
}
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city_name),
"&limit=1&appid=", api_key
)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
# Optional: Print a string displaying the city name and latitude / longitude.
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
# Step 2: Use the One Call API to get the past 5 days of weather data
# Step 2a: Define the date range (modify this as needed)
date_range <- as.character(lubridate::today() - days(1:5)) # past 5 days
# Step 2b: Initialize data frame to hold the outputs. "p5weather" for past 5 weather.
p5weather <- data.frame()
# Step 2c: Loop over dates and make an API call for each day. For every date in the date vector, supply latitude, longitude, the different date, API key, and provide unit preference.
for (date in date_range) {
weather_url <- paste0(
"https://api.openweathermap.org/data/3.0/onecall/day_summary?",
"lat=", lat,
"&lon=", lon,
"&date=", date,
"&appid=", api_key,
"&units=imperial"
)
# Step 2d: Make the API call using the different weather_url queries for each date. Store these in weather_response
weather_response <- GET(weather_url)
# Step 2e: Use logic to evaluate the response and use fromJSON() to get the content from the JSON output and use "flatten = TRUE" to unnest the data.
if (status_code(weather_response) == 200) {
weather_parsed <- jsonlite::fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 2f: Use the output for each day and assign it into a data frame.
daily_df <- as.data.frame(weather_parsed)
# Step 2g: Add date and city name columns
daily_df$city <- city_name
daily_df$date <- date
# Step 2h: Use rbind() to add all the rows to the p5weather data frame.
p5weather <- rbind(df4, daily_df)
} else {
# Step 2i: Use logic (else) to print an error message for when weather data is not obtained.
warning(paste("Failed to get weather for", date, "-", status_code(weather_response)))
}
}
print(p5weather)
} else {
stop("Geocoding failed. Check your API key or city name.")
}
View(p5weather)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
# Optional: Print a string displaying the city name and latitude / longitude.
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
# Step 2: Use the One Call API to get the past 5 days of weather data
# Step 2a: Define the date range (modify this as needed)
date_range <- as.character(lubridate::today() - days(1:5)) # past 5 days
# Step 2b: Initialize data frame to hold the outputs. "p5weather" for past 5 weather.
p5weather <- data.frame()
# Step 2c: Loop over dates and make an API call for each day. For every date in the date vector, supply latitude, longitude, the different date, API key, and provide unit preference.
for (date in date_range) {
weather_url <- paste0(
"https://api.openweathermap.org/data/3.0/onecall/day_summary?",
"lat=", lat,
"&lon=", lon,
"&date=", date,
"&appid=", api_key,
"&units=imperial"
)
# Step 2d: Make the API call using the different weather_url queries for each date. Store these in weather_response
weather_response <- GET(weather_url)
# Step 2e: Use logic to evaluate the response and use fromJSON() to get the content from the JSON output and use "flatten = TRUE" to unnest the data.
if (status_code(weather_response) == 200) {
weather_parsed <- jsonlite::fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 2f: Use the output for each day and assign it into a data frame.
daily_df <- as.data.frame(weather_parsed)
# Step 2g: Add date and city name columns
daily_df$city <- city_name
daily_df$date <- date
# Step 2h: Use rbind() to add all the rows to the p5weather data frame.
p5weather <- rbind(p5weather, daily_df)
} else {
# Step 2i: Use logic (else) to print an error message for when weather data is not obtained.
warning(paste("Failed to get weather for", date, "-", status_code(weather_response)))
}
}
print(p5weather)
} else {
stop("Geocoding failed. Check your API key or city name.")
}
df4 <- p5weather |>  mutate(date = as.Date(date))
ggplot(df4, aes(x = date)) +
geom_line(aes(y = temperature.max, color = "High"), size = 1.2) +
geom_line(aes(y = temperature.min, color = "Low"), size = 1.2) +
scale_color_manual(values = c("High" = "red", "Low" = "blue")) +
labs(
title = paste("High and Low Temperatures in", unique(df4$city)),
x = "Date",
y = "Temperature (Â°F)",
color = "Temperature Type"
) +
theme_minimal(base_size = 14)
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city_name),
"&limit=1&appid=", api_key
)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits =2)
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
# Step 3: Loop through timestamps to fetch historical weather
weather_list <- list()
weather_url <- paste0(
"https://api.openweathermap.org/data/3.0/onecall/day_summary?",
"lat=", lat,
"&lon=", lon,
"&date=", today(),
"&appid=", api_key,
"&units=imperial"
)
weather_response <- GET(weather_url)
if (status_code(weather_response) == 200) {
weather_parsed <- fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
df3 <- as.data.frame(parsed)
}else print("no")
}
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"
current_query <- list(q = city_name, appid = api_key, units = "imperial")
response <- GET(current_weather_url, query = current_query)
http_type(response)
if (status_code(response) == 200) {
# Parse and flatten JSON
content_json <- content(response, as = "text", encoding = "UTF-8")
parsed <- fromJSON(content_json, flatten = TRUE)
# Convert to data frame directly
df <- as.data.frame(parsed)
print(names(df))
} else {
cat("Failed. Status code:", status_code(response), "\n")
}
json_result <- content(response, as = "parsed")
class(json_result)
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city_name),
"&limit=1&appid=", api_key
)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits =2)
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
# Step 3: Loop through timestamps to fetch historical weather
weather_list <- list()
weather_url <- paste0(
"https://api.openweathermap.org/data/3.0/onecall/day_summary?",
"lat=", lat,
"&lon=", lon,
"&date=", today(),
"&appid=", api_key,
"&units=imperial"
)
weather_response <- GET(weather_url)
if (status_code(weather_response) == 200) {
weather_parsed <- fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
df3 <- as.data.frame(parsed)
}else print("no")
}
View(df)
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"
current_query <- list(q = city_name, appid = api_key, units = "imperial")
response <- GET(current_weather_url, query = current_query)
http_type(response)
if (status_code(response) == 200) {
# Parse and flatten JSON
content_json <- content(response, as = "text", encoding = "UTF-8")
parsed <- fromJSON(content_json, flatten = TRUE)
# Convert to data frame directly
currweather <- as.data.frame(parsed)
print(names(currweather))
} else {
cat("Failed. Status code:", status_code(response), "\n")
}
json_result <- content(response, as = "parsed")
class(json_result)
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city_name),
"&limit=1&appid=", api_key
)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
# Optional: Print a string displaying the city name and latitude / longitude.
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
}
geocode("San Francisco")
geocode <- function(city){
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city),
"&limit=1&appid=", api_key
)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
# Optional: Print a string displaying the city name and latitude / longitude.
return(cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n"))
}
}
geocode("San Francisco")
geocode <- function(city){
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city),
"&limit=1&appid=", api_key
)
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
# Optional: Print a string displaying the city name and latitude / longitude.
return(cat("Coordinates for", city, "-> Latitude:", lat, "Longitude:", lon, "\n"))
}
}
geocode("San Francisco")
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"
current_query <- list(q = city_name, appid = api_key, units = "imperial")
response <- GET(current_weather_url, query = current_query)
http_type(response)
if (status_code(response) == 200) {
# Parse and flatten JSON
content_json <- content(response, as = "text", encoding = "UTF-8")
parsed <- fromJSON(content_json, flatten = TRUE)
# Convert to data frame directly
currweather <- as.data.frame(parsed)
print(names(currweather))
} else {
cat("Failed. Status code:", status_code(response), "\n")
}
json_result <- content(response, as = "parsed")
class(json_result)
print(currweather)
load_dot_env(file = ".env")
load_dot_env(file = ".env")
wd <- getwd()
setwd("..")
load_dot_env(file = ".env")
wd <- getwd()
setwd("..")
load_dot_env(file = ".env")
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env")
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env")
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env.txt")
parent <- getwd()
setwd(wd)
api_key <- "c3511200cde7b3702ac398e6a49d370e"
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env.txt")
parent <- getwd()
setwd(wd)
api_key <-
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env.txt")
parent <- getwd()
setwd(wd)
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env.txt")
parent <- getwd()
setwd(wd)
api_key = "c3511200cde7b3702ac398e6a49d370e"
library(httr2)
library(tibble)
library(jsonlite)
library(httr)
library(lubridate)
library(ggplot2)
library(dplyr)
library(dotenv)
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env.txt")
parent <- getwd()
setwd(wd)
api_key = "c3511200cde7b3702ac398e6a49d370e"
city_name <- "San Luis Obispo"
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"
current_query <- list(q = city_name, appid = api_key, units = "imperial")
response <- GET(current_weather_url, query = current_query)
http_type(response)
if (status_code(response) == 200) {
# Parse and flatten JSON
content_json <- content(response, as = "text", encoding = "UTF-8")
parsed <- fromJSON(content_json, flatten = TRUE)
# Convert to data frame directly
currweather <- as.data.frame(parsed)
print(names(currweather))
} else {
cat("Failed. Status code:", status_code(response), "\n")
}
json_result <- content(response, as = "parsed")
class(json_result)
print(currweather)
numdays <- 5
library(httr2)
library(tibble)
library(jsonlite)
library(httr)
library(lubridate)
library(ggplot2)
library(dplyr)
library(dotenv)
geo_response <- GET(geo_url)
library(httr2)
library(tibble)
library(jsonlite)
library(httr)
library(lubridate)
library(ggplot2)
library(dplyr)
library(dotenv)
wd <- getwd()
setwd("..")
load_dot_env(file = "EV.env.txt")
parent <- getwd()
setwd(wd)
api_key = "c3511200cde7b3702ac398e6a49d370e"
city_name <- "San Luis Obispo"
current_weather_url <- "https://api.openweathermap.org/data/2.5/weather"
current_query <- list(q = city_name, appid = api_key, units = "imperial")
response <- GET(current_weather_url, query = current_query)
http_type(response)
if (status_code(response) == 200) {
# Parse and flatten JSON
content_json <- content(response, as = "text", encoding = "UTF-8")
parsed <- fromJSON(content_json, flatten = TRUE)
# Convert to data frame directly
currweather <- as.data.frame(parsed)
print(names(currweather))
} else {
cat("Failed. Status code:", status_code(response), "\n")
}
json_result <- content(response, as = "parsed")
class(json_result)
print(currweather)
geo_url <- paste0(
"http://api.openweathermap.org/geo/1.0/direct?",
"q=", URLencode(city_name),
"&limit=1&appid=", api_key
)
numdays <- 5
geo_response <- GET(geo_url)
if (status_code(geo_response) == 200) {
geo_data <- fromJSON(content(geo_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 1c: Assess if the output has 0 length, meaning no result. If so, stop and display an error message.
if (length(geo_data) == 0) {
stop("City not found. Please check the city name.")
}
# Step 1d: Assign latitude and longitude to variables, and use round() to clip it down to 2 decimal places.
lat <- round(geo_data$lat, digits = 2)
lon <- round(geo_data$lon, digits = 2)
# Optional: Print a string displaying the city name and latitude / longitude.
cat("Coordinates for", city_name, "-> Latitude:", lat, "Longitude:", lon, "\n")
# Step 2: Use the One Call API to get the past 5 days of weather data
# Step 2a: Define the date range (modify this as needed)
date_range <- as.character(lubridate::today() - days(1:numdays)) # past 5 days turn into argumen to pass into function
# Step 2b: Initialize data frame to hold the outputs. "p5weather" for past 5 weather.
p5weather <- data.frame()
# Step 2c: Loop over dates and make an API call for each day. For every date in the date vector, supply latitude, longitude, the different date, API key, and provide unit preference.
for (date in date_range) {
weather_url <- paste0(
"https://api.openweathermap.org/data/3.0/onecall/day_summary?",
"lat=", lat,
"&lon=", lon,
"&date=", date,
"&appid=", api_key,
"&units=imperial"
)
# Step 2d: Make the API call using the different weather_url queries for each date. Store these in weather_response
weather_response <- GET(weather_url)
# Step 2e: Use logic to evaluate the response and use fromJSON() to get the content from the JSON output and use "flatten = TRUE" to unnest the data.
if (status_code(weather_response) == 200) {
weather_parsed <- jsonlite::fromJSON(content(weather_response, as = "text", encoding = "UTF-8"), flatten = TRUE)
# Step 2f: Use the output for each day and assign it into a data frame.
daily_df <- as.data.frame(weather_parsed)
# Step 2g: Add date and city name columns ## USE MUTATE
daily_df$city <- city_name
daily_df$date <- date
# Step 2h: Use rbind() to add all the rows to the p5weather data frame.
p5weather <- bind_rows(p5weather, daily_df)
} else {
# Step 2i: Use logic (else) to print an error message for when weather data is not obtained.
warning(paste("Failed to get weather for", date, "-", status_code(weather_response)))
}
}
print(p5weather)
} else {
stop("Geocoding failed. Check your API key or city name.")
}
View(p5weather)
load("C:/Users/ciera/Desktop/project-86-ETV-nfl-outcomes/.RData")
load("C:/Users/ciera/Desktop/project-86-ETV-nfl-outcomes/.RData")
load("C:/Users/ciera/Desktop/project-86-ETV-nfl-outcomes/.RData")
ls()
source(".RData")
save(api_key)
help(save)
